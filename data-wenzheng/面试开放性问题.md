##### CPU 100

1. top命令查看哪个进程CPU占比比较高
2. top -Hp pid 查看进程下的线程的情况，找到CPU占比较高的线程id
3. 将线程id转换成十六进制形式，jstack 进程id | grep 十六进制形式的线程id
4. 根据线程的虚拟机栈中线程信息寻找原因。

常见的CPU100的原因：

- Java 内存不够或溢出导致GC overhead问题, GC overhead 导致的CPU 100%问题;
- 死循环问题. 如常见的HashMap被多个线程并发使用导致的死循环, 或者上面例子中的死循环;
- 某些特费CPU的操作被长期执行.
- 频繁的获取/释放锁

#### 接口慢的排查

##### 网络原因

##### 非网络原因

- 内存使用过高，导致频繁GC

1. 使用top命令查找出使用CPU较多的进程
2. 使用top -Hp 进程id 查看进程内哪些线程使用CPU较多
3. 将线程id转换成16进制
4. jstack 进程id ｜ grep 线程id的16进制表示 查看线程虚拟机栈
5. jstat -gc 进程id。 查看GC情况
6. jmap 进程id 查看堆中内存的使用情况

- 内存使用不高，出现了死循环
  与频繁GC情况排查类似
- 死锁

1. jps 找出java进程
2. jstack 进程id 看一下线程虚拟机栈观察是否有死锁