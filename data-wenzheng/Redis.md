## Redis

#### Redis中String底层实现？好处？

**bigKey带来的问题？**

- **阻塞Redis服务**。假设，操作一个bigkey需要1s时间（可能是从zset中取出来一定分值范围的元素，而这个范围内的元素数比较多），因为redis服务器是单线程的，所以在这1s内只能处理这一个命令，后面的命令就会被阻塞掉。
- **导致网络阻塞，发送一个bigKey，会消耗大量网络资源。**
- **对value的序列化和反序列化将更耗费CPU资源。**

**为什么会产生bigKey？**

- 社交类应用：一个明星的粉丝多达100万，如果都存放了一个key中就会形成BigKey
- 统计类应用：统计网站访问的用户，如果都放在一个set中，会导致BigKey
- 缓存类应用：将整个数据放在Redis中，数据比较大时，也会产生BigKey

**如何发现bigKey？** 使用redis-cli -h(ip) -p(port) --bigkeys 来发现bigKey，并不会阻塞redis服务器

1. Redis为什么设计成一个单线程？

   这里的单线程只是说在处理客户端的请求时使用的单线程，但是其实在执行BGSAVE时还是使用了一个子进程。
   Redis是**基于内存进行操作**的，处理一个客户端命令只是进行一些内存操作，速度非常快，CPU忙的过来。如果采用每个线程监控一个Socket的多线程方案的话，**Redis在很快处理完一条命令之后就会阻塞线程**，进行线程切换，线程切换的代价是很昂贵的，有可能真正执行一条命令的时间会小于线程切换的时间，这样CPU资源就浪费啦。**Redis的瓶颈是网络的快慢，而不是CPU**。但是如果采用Redis的**单线程加IO多路复用的技术**，就可以实现在同一个线程内同时监控多个Socket，在一个Socket就绪之后很快能处理完这个Socket的请求，再处理下一个，充分的利用了CPU资源。

2. Redis是单线程，为什么还这么快？

   Redis基于内存进行操作，速度非常快。
   Redis中的数据结构是专门进行设计过的，数据操作简单。
   Redis使用单线程，避免了多线程的上下文切换的开销，不用考虑线程之间的同步问题。
   Redis采用了IO多路复用技术，可以在一个线程内同时处理多个Socket。

3. Redis中的数据结构

   String

   List（压缩链表、双向链表->当**列表中包含了数量比较多的元素**或者**包含的元素都是比较长的字符串时**）

   **双向链表的特点无环**、**带头尾节点**、**带链表长度计数器**

   Hash （压缩链表、字典->**包含的键值对比较多**或者**键值对中的元素是比较长的字符串时**）

   **字典的rehash**：字典采用的是渐进式rehash，这个rehash既可能是将字典扩大也可能是将字典缩小。字典中保存了两个哈希表，在正常使用时用的是table[0]，在rehash期间还要使用table[1]。rehash开始时为table[1]计算出合适的容量并分配空间，并设置一个索引index为0，表示rehash table[0]中哪一行，自此之后每次执行添加、删除、查找或者更新时，**除了正常的执行命令之外都会将table[0]上index这一行的数据rehash到table[1]上**，然后index加一。这样随着字段操作的不断进行，table[0]就会变成空的，这时候rehash完成，用table[1]替换掉table[0]，rehash过程才算完成。

   **rehash的时机**：当负载因子过大或者过小是都会执行rehash，负载因子过大就会扩展字典，负载因子过小就会收缩字典。1、如果服务器正在执行BGSAVE或者BGREWRITEAOF时，当负载因子**大于等于5**时rehash。2、如果服务器**不在**执行BGSAVE或者BGREWRITEAOF时，当负载因子**大于等于1**时rehash。3、当负载因子**小于0.1**时，rehash。

   **rehash期间的问题**：rehash整个过程中，数据同时存在table[0]和table[1]中，这样**对字段的删除、查找、更新都要在两个哈希表上进行**。**新增直接新增到table[1]**。

   **rehash中table[1]的大小**：1、扩展操作：table[1]的大小是**大于等于**2 * table[0].length 的最小的2的幂，有点类似于HashMap的扩容操作 2、收缩操作：table[1]的大小是**大于等于** table[0].length 的最小的2的幂。

   Set

   Zset （压缩链表、跳表->当**zset包含的元素比较多**或者**zset中的元素是比较长的字符串时**）

   注意：**节点是按照分值从小到大进行排列的**

   BitMaps （SSD 简单动态字符串）

   Hyperloglogs

   Geospatial

   压缩链表的缺点：特定场景下会照成链表节点的**连锁更新**

   1. Redis中的Lua脚本

   https://segmentfault.com/a/1190000019676878

   常用命令：

   Lua脚本中：redis.call redis.pcalll

   Redis命令：EVAL、EVALSHA、SCRIPT LOAD、SCRIPT EXISTS、SCRIPT FLUSH、SCRIPT KILL

   **Lua脚本为什么能保障原子性？**

   **Redis服务器会将整个脚本作为一个整体来执行** + Redis是单线程的，所以可以保证Lua脚本的原子性。

   **为什么使用Lua脚本？**

   - 减少网络请求，可以在同一个Lua脚本中执行多条Redis命令。这样只需要发送一次，就可以执行多条命令，减少网络往返时延。
   - 原子性，Lua脚本可以保障原子性
   - Lua脚本缓存，Lua脚本被执行之后，就会被缓存在Redis服务器的lua_scripts属性中，其他客户端只需要提供Lua脚本的校验码就可以调用同一个脚本。

**应用场景？**

- 延时队列

  ZSET，value是序列化后的消息，score是消息的消费时间（一定比当前时间戳大）。使用时，轮询ZSET，找到score大于now的消息。使用Lua脚本保证查询消息和删除消息的原子性。

- 自增ID

  使用Lua脚本保证ID的get和set的原子性。

- 分布式锁

- 抢红包

1. Redis中单个命令为什么是原子性的？

   Redis是单线程的，在单个线程中，客户端发送过来的命令一个一个执行完毕，执行完上一个才能执行下一个，所以Redis中的命令是线程安全的。

2. Redis中的通信协议

   **protocol通信协议**